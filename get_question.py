import json
import os

import requests
from dotenv import load_dotenv

load_dotenv()
from openai import OpenAI

client = OpenAI(
    api_key=os.environ.get("OPENAI_API_KEY"),
)

class Question:
    question_title = ""
    question_type = ""
    can_answer = True
    choices = []
    _id = ""

    def __init__(self, question_id, question_title, question_type, can_answer, choices, answer):
        self.question_id = question_id
        self.question_title = question_title
        self.question_type = question_type
        self.can_answer = can_answer
        self.choices = choices
        self.answer = answer

    def answer_to_string(self):
        if len(self.answer) == 1:
            # 提取单个字典中的 "choice" 值
            return self.answer[0]["choice"] if "choice" in self.answer[0] else "No choice available"
        # 遍历并提取每个字典中的 "choice" 值
        return "\n".join(f"{i + 1}. {choice['choice']}" for i, choice in enumerate(self.answer) if "choice" in choice)

    def to_string(self):
        result = (
                "Question: " + self.question_title + '\n'
                + "Type: " + self.question_type + '\n'
                + "Answerable: " + str(self.can_answer) + '\n'
        )
        # 拼接 Answer
        result += "Answer: " + self.answer_to_string() + '\n'

        if self.question_type == "OpenQuestion" or self.question_type == "Poll":
            result += "generated by gpt-4o-mini." + '\n'
        return result

headers = {
        "Authorization": f"Bearer {os.getenv("token")}",
        "User-Agent": os.getenv("user_agent"),
        "Accept": "application/json"
    }

def authenticate(lesson_code):
    url = f"https://app.wooclap.com/api/presentation/events/{lesson_code}/authentications"
    try:
        response = requests.get(url=url, headers=headers)
        if response.status_code == 200:
            print("Authenticate successfully!")
            json_data = response.json()
            _id = json_data.get("_id", None)
            if _id:
                ret = participant(_id)
                if ret:
                    return True
            return False
        else:
            print("Authenticate failed!" + response.text)
            return False
    except Exception as e:
        print(e)
        return False

def participant(_id):
    url = f"https://app.wooclap.com/api/presentation/events/{_id}/participants"
    try:
        response = requests.post(url=url, headers=headers)
        if response.status_code == 201:
            print("Participant successfully!")
            return True
        else:
            print("Participant failed!")
            return False
    except Exception as e:
        print(e)
        return False

def handle_message(lesson_code):
    # 提取 lesson_code
    try:
        if len(lesson_code) != 6:
            lesson_code = lesson_code.split('\u2005')[1]
    except IndexError:
        return "Invalid lesson code format"

    with open("data.json", "r", encoding="utf-8") as file:
        data = json.load(file)
        latest_lesson_code = data.get("latest_lesson_code", None)
        latest_question_id = data.get("latest_question_id", None)

    # switch lesson code
    if latest_lesson_code != lesson_code:
        authenticate(lesson_code)

    url = f"https://app.wooclap.com/api/events/{lesson_code}?isParticipant=true&from="
    response = requests.get(url=url, headers=headers)

    if response.status_code == 200:
        print("Request successfully!")
        try:
            json_data = response.json()
            questions = json_data.get("questions", [])
            select_question = json_data.get("selectedQuestion", None)

            if select_question is None or select_question == latest_question_id:
                # no updates
                return "\nThere is no question now."

            try:
                with open("data.json", "r", encoding="utf-8") as file:
                    data = json.load(file)
            except FileNotFoundError:
                data = {}  # 如果文件不存在，创建一个空字典

            answers = []

            for question in questions:
                tmp_question = process_question(question)
                if tmp_question and tmp_question.question_title != "Untitled Question":
                    answers.append(tmp_question)

            if len(answers) == 0:
                return "\nThere is no question now."

            data["questions_and_answers"] = [
                {
                    "question_id": q.question_id,
                    "question_title": q.question_title,
                    "question_type": q.question_type,
                    "can_answer": q.can_answer,
                    "choices": q.choices,
                    "answers": q.answer
                }
                for q in answers
            ]
            data["latest_question_id"] = select_question
            data["latest_lesson_code"] = lesson_code

            with open("data.json", "w", encoding="utf-8") as file:
                json.dump(data, file, ensure_ascii=False, indent=4)

            if os.environ.get("AUTO_ANSWER") == "True":
                answer_question()
            return "\n".join(answer.to_string() for answer in answers)
        except (KeyError, ValueError) as e:
            print(f"Error processing JSON response: {e}")
            return "Failed to process questions."
    else:
        print(f"Request failed: {response.status_code}")
        return f"Failed to fetch data for lesson code: {lesson_code}"

def monitor_lesson_impl(lesson_code):
    print("check updates...")
    # get current questions
    result = handle_message(lesson_code)

    if "There is no question now" not in result:
        return True, result
    return False, "No updates"


def process_question(question):
    """处理单个问题并返回 Question 对象"""
    try:
        tmp_question_id = question.get("_id", "Default ID")
        tmp_question_title = question.get("title", "Untitled Question")
        tmp_question_type = question.get("__t", "Unknown Type")
        tmp_question_choices = question.get("choices", [])
        tmp_question_choices = [{
            "choice": choice["choice"],
            "_id": choice["_id"]
        } for choice in tmp_question_choices]

        tmp_question_can_answer = question.get("canAnswer", True)
        tmp_question_answer = []
        # 根据问题类型处理
        if tmp_question_type == "MCQ":

            tmp_question_answer = [{
                "choice": choice["choice"],
                "_id": choice["_id"]
            }
            for choice in question.get("choices", []) if choice.get("isCorrect")]
        elif tmp_question_type == "Poll":
            generate_answer = generate_poll_answer(tmp_question_title, tmp_question_choices)
            tmp_question_answer = [{
                "choice": choice["choice"],
                "_id": choice["_id"]
            }
            for choice in question.get("choices", []) if generate_answer[0] == choice["choice"]]
        elif tmp_question_type == "OpenQuestion":
            generate_answer = generate_poll_answer(tmp_question_title, tmp_question_choices)
            tmp_question_answer = [{
                "choice": answer,
                "_id": ""
            }
            for answer in generate_answer]

        return Question(tmp_question_id, tmp_question_title, tmp_question_type,tmp_question_can_answer, tmp_question_choices, tmp_question_answer)

    except KeyError as e:
        print(f"Missing key in question: {e}")
    except Exception as e:
        print(f"Unexpected error processing question: {e}")
    return None


def generate_poll_answer(title, choices, model = "gpt-4o-mini", temperature = 1, num_answers=3):
    try:
        if choices:
            choices_str = ", ".join([choice["choice"] for choice in choices])
            title = ("Please pick one suitable selection for " + title + " from " + choices_str
                     + ", you must choose one of them and just tell me the selection itself.")
            num_answers = 1
        completion = client.chat.completions.create(
            model=model,
            messages=[
                {"role": "system", "content": "You are a post-graduate student majoring in "
                                              "Blockchain, Nanyang Technological University"},
                {
                    "role": "user",
                    "content": "Say some thing when it comes to: " + title + ". Words' length should be under 5."
                }
            ],
            temperature=temperature,
            n=num_answers
        )
        answers = completion.choices
        ret = []
        for answer in answers:
            if answer.message.content not in ret:
                ret.append(answer.message.content)
        return ret
    except Exception as e:
        print(f"Unexpected error processing question: {e}")

def answer_question():
    print("Answering question...")
    try:
        # 读取 JSON 数据
        with open("data.json", "r", encoding="utf-8") as file:
            data = json.load(file)
    except FileNotFoundError:
        print("Error: data.json file not found.")
        return "Failed to process questions."
    except (json.JSONDecodeError, KeyError, ValueError) as e:
        print(f"Error processing JSON response: {e}")
        return "Failed to process questions."

    # 获取最新问题 ID
    question_id = data.get("latest_question_id")
    if not question_id:
        return "No question ID found."

    # 查找对应问题的类型和答案
    questions_and_answers = data.get("questions_and_answers", [])
    question_data = next(
        (q_n_a for q_n_a in questions_and_answers if q_n_a.get("question_id") == question_id),
        None
    )

    if not question_data:
        return f"Question with ID {question_id} not found."

    question_type = question_data.get("question_type")
    answers = question_data.get("answers", [])

    if not answers:
        return f"No answers found for question ID {question_id}."

    # 构建请求数据
    answer_be_pushed = {}
    if question_type in ["MCQ", "Poll"]:
        answer_be_pushed = {
            "choices": [
                {
                    "_id": answer.get("_id", ""),
                    "comment": ""
                }
                for answer in answers if "_id" in answer
            ]
        }
    elif question_type == "OpenQuestion" and answers:
        answer_be_pushed = {
            "text": answers[0] if isinstance(answers[0], str) else ""
        }
    else:
        return f"Unsupported question type: {question_type}"

    # 发送答案到服务器
    answer_url = f"https://app.wooclap.com/api/questions/{question_id}/push_answer"

    try:
        response = requests.post(url=answer_url, headers=headers, json=answer_be_pushed)
        response_json = response.json()
        if response_json.get("error", None):
            if response_json.get("error").get("errorCode") == "USER_ALREADY_ANSWERED_OR_QUESTION_LOCKED":
                print("USER_ALREADY_ANSWERED_OR_QUESTION_LOCKED")
        else:
            response.raise_for_status()  # 检查是否有 HTTP 错误
            print("Answer submitted successfully:", response.json())
        return response.json()
    except requests.RequestException as e:
        print(f"Error submitting answer: {e}")
        return "Failed to submit answer."

if __name__ == '__main__':
    answer_question("XGCQIO")
# https://app.wooclap.com/api/presentation/events/ORXGFG/authentications
# _id : 674837fd20ce09c177c4f272
# https://app.wooclap.com/api/presentation/events/6748388f33864d988f809ff4/participants
#